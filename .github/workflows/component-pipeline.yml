name: Component Publishing Pipeline

on:
  workflow_dispatch:
    inputs:
      skip_validation:
        description: 'Skip validation and just update index'
        required: false
        default: 'false'
        type: boolean
      force_update:
        description: 'Force update even if no changes detected'
        required: false
        default: 'false'
        type: boolean
  
  push:
    branches: [main, develop]
    paths:
      - 'components/**'
      - 'registry.json'
  
  pull_request:
    branches: [main, develop]
    types: [opened, synchronize, reopened, closed]

jobs:
  validate:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    if: |
      github.event_name == 'workflow_dispatch' && github.event.inputs.skip_validation == 'true'
      || github.event_name != 'workflow_dispatch'
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: ⚙️ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: 📦 Install SCM CLI
        run: |
          echo "📦 Installing SCM CLI..."
          npm install -g @shadcn-component-manager/scm || echo "⚠️ SCM CLI not available yet, skipping installation"
        
      - name: 📋 Validate registry.json structure
        id: validate-registry
        run: |
          if [ -f "registry.json" ]; then
            node -e "
              const fs = require('fs');
              try {
                const registry = JSON.parse(fs.readFileSync('registry.json', 'utf8'));
                
                // Check if it's a registry collection (has items array) or single item
                if (registry.items && Array.isArray(registry.items)) {
                  // This is a registry collection
                  if (!registry.name) {
                    console.error('❌ Registry collection missing required field: name');
                    process.exit(1);
                  }
                  if (!registry.homepage) {
                    console.error('❌ Registry collection missing required field: homepage');
                    process.exit(1);
                  }
                  console.log(\`✅ registry.json is valid registry collection with \${registry.items.length} items\`);
                } else {
                  // This is a single registry item or array of items
                  if (Array.isArray(registry)) {
                    console.log(\`✅ registry.json is valid array with \${registry.length} components\`);
                  } else {
                    // Single item - validate it has required fields
                    if (!registry.name) {
                      console.error('❌ Registry item missing required field: name');
                      process.exit(1);
                    }
                    if (!registry.type) {
                      console.error('❌ Registry item missing required field: type');
                  process.exit(1);
                    }
                    console.log('✅ registry.json is valid single registry item');
                  }
                }
              } catch (error) {
                console.error('❌ registry.json is not valid JSON:', error.message);
                process.exit(1);
              }
            "
            echo "registry_valid=true" >> $GITHUB_OUTPUT
          else
            echo "⚠️ registry.json not found - will be generated by update-index workflow"
            echo "registry_valid=true" >> $GITHUB_OUTPUT
          fi
          
      - name: 🔄 Get changed components
        id: changed-components
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            CHANGED_COMPONENTS=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | grep "components/.*/registry.json" | sed 's|components/\([^/]*/[^/]*/[^/]*\)/registry.json|\1|' || echo "")
            echo "changed_components=$CHANGED_COMPONENTS" >> $GITHUB_OUTPUT
          else
            echo "changed_components=" >> $GITHUB_OUTPUT
          fi

      - name: 🔍 Validate changed components only
        id: validate-components
        run: |
          if [ ! -d "components" ]; then
            echo "components_valid=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ "${{ github.event_name }}" == "pull_request" ] && [ -n "${{ steps.changed-components.outputs.changed_components }}" ]; then
            # Only validate changed components
            for component in ${{ steps.changed-components.outputs.changed_components }}; do
              componentPath="components/${component}/registry.json"
              if [ -f "$componentPath" ]; then
                node -e "
                  const fs = require(\"fs\");
                  const path = require(\"path\");
                  const componentPath = \"$componentPath\";
                  const componentDir = path.dirname(componentPath);
                  
                  try {
                    const metadata = JSON.parse(fs.readFileSync(componentPath, \"utf8\"));
                    
                    if (!metadata.name) {
                      console.error(\`Missing required field: name\`);
                      process.exit(1);
                    }
                    
                    const namePattern = /^[a-z][a-z0-9-]*[a-z0-9]$/;
                    if (!namePattern.test(metadata.name)) {
                      console.error(\`Invalid name format: \${metadata.name}\`);
                      process.exit(1);
                    }
                    
                    if (metadata.name.length < 2 || metadata.name.length > 50) {
                      console.error(\`Invalid name length: \${metadata.name}\`);
                      process.exit(1);
                    }
                    
                    if (metadata.name.includes(\"--\")) {
                      console.error(\`Invalid name: \${metadata.name}\`);
                      process.exit(1);
                    }
                    
                    if (!metadata.type) {
                      console.error(\`Missing required field: type\`);
                      process.exit(1);
                    }
                    
                    const validTypes = [\"registry:lib\", \"registry:block\", \"registry:internal\", \"registry:example\", \"registry:component\", \"registry:ui\", \"registry:hook\", \"registry:theme\", \"registry:page\", \"registry:file\", \"registry:style\"];
                    if (!validTypes.includes(metadata.type)) {
                      console.error(\`Invalid type: \${metadata.type}\`);
                      process.exit(1);
                    }
                    
                    if (metadata.title && metadata.title.length > 200) {
                      console.error(\`Title too long: \${metadata.title}\`);
                      process.exit(1);
                    }
                    
                    if (metadata.description && metadata.description.length > 1000) {
                      console.error(\`Description too long: \${metadata.description}\`);
                      process.exit(1);
                    }
                    
                    if (metadata.author && metadata.author.length > 200) {
                      console.error(\`Author too long: \${metadata.author}\`);
                      process.exit(1);
                    }
                    
                    if (metadata.dependencies && (!Array.isArray(metadata.dependencies) || metadata.dependencies.length > 100)) {
                      console.error(\`Invalid dependencies\`);
                      process.exit(1);
                    }
                    
                    if (metadata.devDependencies && (!Array.isArray(metadata.devDependencies) || metadata.devDependencies.length > 100)) {
                      console.error(\`Invalid devDependencies\`);
                      process.exit(1);
                    }
                    
                    if (metadata.registryDependencies && (!Array.isArray(metadata.registryDependencies) || metadata.registryDependencies.length > 100)) {
                      console.error(\`Invalid registryDependencies\`);
                      process.exit(1);
                    }
                    
                    if (metadata.categories && (!Array.isArray(metadata.categories) || metadata.categories.length > 20)) {
                      console.error(\`Invalid categories\`);
                      process.exit(1);
                    }
                    
                    if (metadata.files && (!Array.isArray(metadata.files) || metadata.files.length > 50)) {
                      console.error(\`Invalid files\`);
                      process.exit(1);
                    }
                    
                    if (metadata.files && Array.isArray(metadata.files)) {
                      for (const file of metadata.files) {
                        if (!file.path) {
                          console.error(\`File entry missing path field\`);
                          process.exit(1);
                        }
                        
                        if (file.path.length > 500) {
                          console.error(\`File path too long: \${file.path}\`);
                          process.exit(1);
                        }
                        
                        const filePath = path.join(componentDir, file.path);
                        if (!fs.existsSync(filePath)) {
                          console.error(\`File not found: \${file.path}\`);
                          process.exit(1);
                        }
                        
                        try {
                          const stats = fs.statSync(filePath);
                          const maxSize = 1024 * 1024 * 100;
                          if (stats.size > maxSize) {
                            console.error(\`File too large: \${file.path}\`);
                            process.exit(1);
                          }
                        } catch (error) {
                          console.error(\`File not readable: \${file.path}\`);
                          process.exit(1);
                        }
                      }
                    }
                    
                    if (metadata.version) {
                      const versionPattern = /^\d+\.\d+\.\d+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$/;
                      if (!versionPattern.test(metadata.version)) {
                        console.error(\`Invalid version format: \${metadata.version}\`);
                        process.exit(1);
                      }
                    }
                  } catch (error) {
                    console.error(\`Error validating \${componentPath}:\`, error.message);
                    process.exit(1);
                  }
                "
              fi
            done
          else
            # For non-PR events, validate all components (fallback)
          find components -name "registry.json" -exec sh -c '
            node -e "
              const fs = require(\"fs\");
              const path = require(\"path\");
              const componentPath = \"$1\";
              const componentDir = path.dirname(componentPath);
              
              try {
                const metadata = JSON.parse(fs.readFileSync(componentPath, \"utf8\"));
                
                  if (!metadata.name) {
                    console.error(\`Missing required field: name\`);
                    process.exit(1);
                  }
                  
                  const namePattern = /^[a-z][a-z0-9-]*[a-z0-9]$/;
                  if (!namePattern.test(metadata.name)) {
                    console.error(\`Invalid name format: \${metadata.name}\`);
                    process.exit(1);
                  }
                  
                  if (metadata.name.length < 2 || metadata.name.length > 50) {
                    console.error(\`Invalid name length: \${metadata.name}\`);
                    process.exit(1);
                  }
                  
                  if (metadata.name.includes(\"--\")) {
                    console.error(\`Invalid name: \${metadata.name}\`);
                    process.exit(1);
                  }
                  
                  if (!metadata.type) {
                    console.error(\`Missing required field: type\`);
                    process.exit(1);
                }
                
                  const validTypes = [\"registry:lib\", \"registry:block\", \"registry:internal\", \"registry:example\", \"registry:component\", \"registry:ui\", \"registry:hook\", \"registry:theme\", \"registry:page\", \"registry:file\", \"registry:style\"];
                if (!validTypes.includes(metadata.type)) {
                    console.error(\`Invalid type: \${metadata.type}\`);
                    process.exit(1);
                  }
                  
                  if (metadata.title && metadata.title.length > 200) {
                    console.error(\`Title too long: \${metadata.title}\`);
                    process.exit(1);
                  }
                  
                  if (metadata.description && metadata.description.length > 1000) {
                    console.error(\`Description too long: \${metadata.description}\`);
                    process.exit(1);
                  }
                  
                  if (metadata.author && metadata.author.length > 200) {
                    console.error(\`Author too long: \${metadata.author}\`);
                    process.exit(1);
                  }
                  
                  if (metadata.dependencies && (!Array.isArray(metadata.dependencies) || metadata.dependencies.length > 100)) {
                    console.error(\`Invalid dependencies\`);
                    process.exit(1);
                  }
                  
                  if (metadata.devDependencies && (!Array.isArray(metadata.devDependencies) || metadata.devDependencies.length > 100)) {
                    console.error(\`Invalid devDependencies\`);
                    process.exit(1);
                  }
                  
                  if (metadata.registryDependencies && (!Array.isArray(metadata.registryDependencies) || metadata.registryDependencies.length > 100)) {
                    console.error(\`Invalid registryDependencies\`);
                    process.exit(1);
                  }
                  
                  if (metadata.categories && (!Array.isArray(metadata.categories) || metadata.categories.length > 20)) {
                    console.error(\`Invalid categories\`);
                    process.exit(1);
                  }
                  
                  if (metadata.files && (!Array.isArray(metadata.files) || metadata.files.length > 50)) {
                    console.error(\`Invalid files\`);
                  process.exit(1);
                }
                
                if (metadata.files && Array.isArray(metadata.files)) {
                  for (const file of metadata.files) {
                    if (!file.path) {
                        console.error(\`File entry missing path field\`);
                        process.exit(1);
                      }
                      
                      if (file.path.length > 500) {
                        console.error(\`File path too long: \${file.path}\`);
                      process.exit(1);
                    }
                      
                    const filePath = path.join(componentDir, file.path);
                    if (!fs.existsSync(filePath)) {
                        console.error(\`File not found: \${file.path}\`);
                        process.exit(1);
                      }
                      
                      try {
                        const stats = fs.statSync(filePath);
                        const maxSize = 1024 * 1024 * 100;
                        if (stats.size > maxSize) {
                          console.error(\`File too large: \${file.path}\`);
                          process.exit(1);
                        }
                      } catch (error) {
                        console.error(\`File not readable: \${file.path}\`);
                      process.exit(1);
                      }
                  }
                }
                
                if (metadata.version) {
                    const versionPattern = /^\d+\.\d+\.\d+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$/;
                    if (!versionPattern.test(metadata.version)) {
                      console.error(\`Invalid version format: \${metadata.version}\`);
                    process.exit(1);
                  }
                }
              } catch (error) {
                  console.error(\`Error validating \${componentPath}:\`, error.message);
                process.exit(1);
              }
            "
          ' _ {} \;
          fi
          
          echo "components_valid=true" >> $GITHUB_OUTPUT
          
      - name: 🏷️ Validate component naming conventions
        id: validate-naming
        run: |
          if [ ! -d "components" ]; then
            echo "components_naming_valid=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ "${{ github.event_name }}" == "pull_request" ] && [ -n "${{ steps.changed-components.outputs.changed_components }}" ]; then
            # Only validate changed components
            for component in ${{ steps.changed-components.outputs.changed_components }}; do
              namespace=$(echo "$component" | cut -d'/' -f1)
              componentName=$(echo "$component" | cut -d'/' -f2)
              
              # Validate namespace format
              if ! echo "$namespace" | grep -qE '^[a-zA-Z0-9_-]+$'; then
                echo "Namespace '$namespace' contains invalid characters"
                exit 1
              fi
              
              if [ ${#namespace} -lt 1 ] || [ ${#namespace} -gt 39 ]; then
                echo "Namespace '$namespace' length invalid"
                exit 1
              fi
              
              # Validate component name format
              if ! echo "$componentName" | grep -qE '^[a-z][a-z0-9-]*[a-z0-9]$'; then
                echo "Component name '$componentName' format invalid"
                exit 1
              fi
              
              # Check reserved names
              reservedNames="node_modules package package.json dist build test tests docs examples main"
              for reserved in $reservedNames; do
                if [ "$(echo "$componentName" | tr '[:upper:]' '[:lower:]')" = "$reserved" ]; then
                  echo "Component name '$componentName' is reserved"
                  exit 1
                fi
              done
              
              # Check name length
              if [ ${#componentName} -lt 2 ] || [ ${#componentName} -gt 50 ]; then
                echo "Component name '$componentName' length invalid"
                exit 1
              fi
              
              # Check for consecutive hyphens
              if echo "$componentName" | grep -q --; then
                echo "Component name '$componentName' cannot contain consecutive hyphens"
                exit 1
              fi
            done
          else
            # For non-PR events, validate all components (fallback)
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            const componentsDir = 'components';
            const reservedNames = [
                \"node_modules\", \"package\", \"package.json\", \"dist\", \"build\", \"test\", \"tests\", \"docs\", \"examples\", \"main\"
            ];
            
            if (fs.existsSync(componentsDir)) {
              const namespaces = fs.readdirSync(componentsDir);
              
              for (const namespace of namespaces) {
                const namespacePath = path.join(componentsDir, namespace);
                if (fs.statSync(namespacePath).isDirectory()) {
                  const componentDirs = fs.readdirSync(namespacePath);
                  
                  for (const componentName of componentDirs) {
                      const namespacePattern = /^[a-zA-Z0-9_-]+$/;
                      if (!namespacePattern.test(namespace)) {
                        console.error(\`Namespace '\${namespace}' contains invalid characters\`);
                        process.exit(1);
                      }
                      
                      if (namespace.length < 1 || namespace.length > 39) {
                        console.error(\`Namespace '\${namespace}' length invalid\`);
                        process.exit(1);
                      }
                      
                      const namePattern = /^[a-z][a-z0-9-]*[a-z0-9]$/;
                      if (!namePattern.test(componentName)) {
                        console.error(\`Component name '\${componentName}' format invalid\`);
                        process.exit(1);
                      }
                      
                      if (reservedNames.includes(componentName.toLowerCase())) {
                        console.error(\`Component name '\${componentName}' is reserved\`);
                        process.exit(1);
                      }
                      
                      if (componentName.length < 2 || componentName.length > 50) {
                        console.error(\`Component name '\${componentName}' length invalid\`);
                      process.exit(1);
                    }
                    
                      if (componentName.includes(\"--\")) {
                        console.error(\`Component name '\${componentName}' cannot contain consecutive hyphens\`);
                      process.exit(1);
                      }
                    }
                  }
                }
              }
            "
          fi
            
          echo "components_naming_valid=true" >> $GITHUB_OUTPUT

      - name: 📊 Validation Summary
        id: validation-summary
        run: |
          if [ "${{ steps.validate-registry.outputs.registry_valid }}" == "true" ] && [ "${{ steps.validate-components.outputs.components_valid }}" == "true" ] && [ "${{ steps.validate-naming.outputs.components_naming_valid }}" == "true" ]; then
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  auto-merge:
    needs: validate
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      checks: write
    if: |
      github.event_name == 'pull_request' && 
      github.event.action != 'closed'
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: 🛠️ Setup GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y
          
      - name: ✅ Check if PR is mergeable
        id: check-mergeable
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          MERGEABLE=$(gh pr view ${{ github.event.pull_request.number }} --json mergeable,mergeStateStatus --jq '.mergeable')
          
          if [ "$MERGEABLE" == "MERGEABLE" ]; then
            echo "merge_ready=true" >> $GITHUB_OUTPUT
          else
            echo "merge_ready=false" >> $GITHUB_OUTPUT
          fi
          
      - name: 🔀 Auto merge PR
        if: steps.check-mergeable.outputs.merge_ready == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh pr merge ${{ github.event.pull_request.number }} --merge --delete-branch
          
      - name: 💬 Comment merge status
        if: steps.check-mergeable.outputs.merge_ready == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          COMPONENT_NAME=$(echo "$PR_TITLE" | sed 's/\[Component\] Add \(.*\) v[0-9]\+\.[0-9]\+\.[0-9]\+.*/\1/')
          USERNAME="${{ github.event.pull_request.user.login }}"
          INSTALL_CMD="scm add ${USERNAME}/${COMPONENT_NAME}"
          
          gh pr comment ${{ github.event.pull_request.number }} --body |
            ✅ **Component Published Successfully**

            **Component:** `${USERNAME}/${COMPONENT_NAME}`
            **Status:** Published and available in registry
            **Install:** `${INSTALL_CMD}`

            Your component is now live and ready for installation by the community! 🚀
          
      - name: ❌ Comment merge blocked
        if: steps.check-mergeable.outputs.merge_ready == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh pr comment ${{ github.event.pull_request.number }} --body |
            ❌ **Validation Failed**

            Please review the validation errors above and fix the issues before resubmitting.

            **Common fixes:**
            - Check component naming conventions
            - Ensure all referenced files exist
            - Validate `registry.json` schema
            - Verify file sizes are under 100MB

  update-index:
    needs: [validate, auto-merge]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    if: |
      (github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push' ||
      (github.event_name == 'pull_request' && (github.event.pull_request.merged == true || needs.auto-merge.result == 'success'))) &&
      needs.validate.result == 'success'
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          
      - name: ⚙️ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: 🔧 Generate registry index
        id: generate-index
        run: |
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            // Read existing index to preserve timestamps
            let existingIndex = [];
            if (fs.existsSync('registry.json')) {
              try {
                existingIndex = JSON.parse(fs.readFileSync('registry.json', 'utf8'));
              } catch (error) {
                console.error('Error reading existing registry.json:', error.message);
              }
            }
            
            const components = [];
            const componentsDir = 'components';
            const newComponents = [];
            
            if (fs.existsSync(componentsDir)) {
              const namespaces = fs.readdirSync(componentsDir);
              
              for (const namespace of namespaces) {
                const namespacePath = path.join(componentsDir, namespace);
                if (fs.statSync(namespacePath).isDirectory()) {
                  const componentDirs = fs.readdirSync(namespacePath);
                  
                  for (const componentName of componentDirs) {
                    const componentPath = path.join(namespacePath, componentName);
                    if (fs.statSync(componentPath).isDirectory()) {
                      const versions = fs.readdirSync(componentPath);
                      const latestVersion = versions.sort().pop();
                      
                      if (latestVersion) {
                        const registryPath = path.join(componentPath, latestVersion, 'registry.json');
                        if (fs.existsSync(registryPath)) {
                          try {
                            const metadata = JSON.parse(fs.readFileSync(registryPath, 'utf8'));
                            const componentKey = \`\${namespace}/\${componentName}\`;
                            
                            // Check if component already exists in index
                            const existingComponent = existingIndex.find(c => c.name === componentKey);
                            
                            if (existingComponent) {
                              // Preserve existing timestamp unless version changed
                              if (existingComponent.version !== latestVersion) {
                                existingComponent.version = latestVersion;
                                existingComponent.lastUpdated = new Date().toISOString();
                                newComponents.push(componentKey);
                              }
                              components.push(existingComponent);
                            } else {
                              // New component
                            components.push({
                                name: componentKey,
                              description: metadata.description || '',
                              author: metadata.author || '',
                              categories: metadata.categories || [],
                              version: latestVersion,
                              lastUpdated: new Date().toISOString()
                            });
                              newComponents.push(componentKey);
                            }
                          } catch (error) {
                            console.error(\`Error parsing \${registryPath}:\`, error.message);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            
            // Sort by last updated
            components.sort((a, b) => new Date(b.lastUpdated) - new Date(a.lastUpdated));
            
            fs.writeFileSync('registry.json', JSON.stringify(components, null, 2));
            
            if (newComponents.length > 0) {
              console.log(\`✅ Added \${newComponents.length} new components: \${newComponents.join(', ')}\`);
            }
          "
          echo "components_count=$(node -e "const fs = require('fs'); const registry = JSON.parse(fs.readFileSync('registry.json', 'utf8')); console.log(registry.length);")" >> $GITHUB_OUTPUT
          
      - name: 🔍 Check for changes
        id: check-changes
        run: |
          git add registry.json
          if git diff --staged --quiet && [ "${{ github.event.inputs.force_update }}" != "true" ]; then
            echo "ℹ️ No changes detected in registry.json"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "✅ Changes detected in registry.json"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi
          
      - name: 📤 Commit and push changes
        if: steps.check-changes.outputs.has_changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Create commit message based on trigger type
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            COMMIT_MSG="chore: manually update registry index [skip ci]"
          elif [ "${{ github.event_name }}" == "push" ]; then
            COMMIT_MSG="chore: update registry index from direct push [skip ci]"
          else
            COMMIT_MSG="chore: update registry index after PR merge [skip ci]"
          fi
          
          git commit -m "$COMMIT_MSG"
          git push origin main
          echo "✅ Registry index updated and pushed"
          
      - name: ℹ️ No changes message
        if: steps.check-changes.outputs.has_changes == 'false'
        run: |
          echo "ℹ️ No changes detected in registry.json - skipping commit"

  cleanup:
    needs: [validate, auto-merge]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    if: |
      github.event_name == 'pull_request' && 
      (github.event.pull_request.merged == true || needs.auto-merge.result == 'success')
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          
      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
      - name: Delete merged branch
        run: |
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          echo "🗑️  Cleaning up merged branch: $BRANCH_NAME"
          
          # Delete the branch locally and remotely
          git push origin --delete "$BRANCH_NAME" || echo "Branch $BRANCH_NAME already deleted or doesn't exist"
          
          echo "✅ Branch cleanup completed" 