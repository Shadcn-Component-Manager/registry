name: Component Publishing Pipeline

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      skip_validation:
        description: 'Skip validation and just update index'
        required: false
        default: 'false'
        type: boolean
      force_update:
        description: 'Force update even if no changes detected'
        required: false
        default: 'false'
        type: boolean
  
  # Direct pushes to main/develop
  push:
    branches: [main, develop]
    paths:
      - 'components/**'
      - 'registry.json'
  
  # Pull requests (existing functionality)
  pull_request:
    branches: [main, develop]
    types: [opened, synchronize, reopened, closed]

jobs:
  # Job 1: Validate component structure and metadata (skipped for manual runs with skip_validation=true)
  validate:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    if: |
      github.event_name == 'workflow_dispatch' && github.event.inputs.skip_validation == 'true'
      || github.event_name != 'workflow_dispatch'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Install SCM CLI
        run: |
          echo "Installing SCM CLI..."
          npm install -g @shadcn-component-manager/scm || echo "SCM CLI not available yet, skipping installation"
        
      - name: Validate registry.json structure
        id: validate-registry
        run: |
          if [ -f "registry.json" ]; then
            node -e "
              const fs = require('fs');
              try {
                const registry = JSON.parse(fs.readFileSync('registry.json', 'utf8'));
                
                // Check if it's a registry collection (has items array) or single item
                if (registry.items && Array.isArray(registry.items)) {
                  // This is a registry collection
                  if (!registry.name) {
                    console.error('‚ùå Registry collection missing required field: name');
                    process.exit(1);
                  }
                  if (!registry.homepage) {
                    console.error('‚ùå Registry collection missing required field: homepage');
                    process.exit(1);
                  }
                  console.log(\`‚úÖ registry.json is valid registry collection with \${registry.items.length} items\`);
                } else {
                  // This is a single registry item or array of items
                  if (Array.isArray(registry)) {
                    console.log(\`‚úÖ registry.json is valid array with \${registry.length} components\`);
                  } else {
                    // Single item - validate it has required fields
                    if (!registry.name) {
                      console.error('‚ùå Registry item missing required field: name');
                      process.exit(1);
                    }
                    if (!registry.type) {
                      console.error('‚ùå Registry item missing required field: type');
                      process.exit(1);
                    }
                    console.log('‚úÖ registry.json is valid single registry item');
                  }
                }
              } catch (error) {
                console.error('‚ùå registry.json is not valid JSON:', error.message);
                process.exit(1);
              }
            "
            echo "registry_valid=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  registry.json not found - will be generated by update-index workflow"
            echo "registry_valid=true" >> $GITHUB_OUTPUT
          fi
          
      - name: Validate component structure
        id: validate-components
        run: |
          if [ ! -d "components" ]; then
            echo "‚ö†Ô∏è  No components directory found"
            echo "components_valid=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          find components -name "registry.json" -exec sh -c '
            echo "üîç Validating $1"
            node -e "
              const fs = require(\"fs\");
              const path = require(\"path\");
              const componentPath = \"$1\";
              const componentDir = path.dirname(componentPath);
              
              try {
                const metadata = JSON.parse(fs.readFileSync(componentPath, \"utf8\"));
                
                // Validate name field (required)
                if (!metadata.name) {
                  console.error(\`‚ùå Missing required field: name\`);
                  process.exit(1);
                }
                
                // Validate name format: lowercase, letters/numbers/hyphens, starts with letter, ends with letter/number
                const namePattern = /^[a-z][a-z0-9-]*[a-z0-9]$/;
                if (!namePattern.test(metadata.name)) {
                  console.error(\`‚ùå Invalid name format: \${metadata.name}. Must start with a letter, contain only lowercase letters, numbers, and hyphens, and end with a letter or number\`);
                  process.exit(1);
                }
                
                // Validate name length (2-50 characters)
                if (metadata.name.length < 2 || metadata.name.length > 50) {
                  console.error(\`‚ùå Invalid name length: \${metadata.name}. Must be between 2 and 50 characters\`);
                  process.exit(1);
                }
                
                // Check for consecutive hyphens
                if (metadata.name.includes(\"--\")) {
                  console.error(\`‚ùå Invalid name: \${metadata.name}. Cannot contain consecutive hyphens\`);
                  process.exit(1);
                }
                
                // Validate type field (required)
                if (!metadata.type) {
                  console.error(\`‚ùå Missing required field: type\`);
                  process.exit(1);
                }
                
                // Validate type field - use exact same types as SCM CLI
                const validTypes = [\"registry:lib\", \"registry:block\", \"registry:internal\", \"registry:example\", \"registry:component\", \"registry:ui\", \"registry:hook\", \"registry:theme\", \"registry:page\", \"registry:file\", \"registry:style\"];
                if (!validTypes.includes(metadata.type)) {
                  console.error(\`‚ùå Invalid type: \${metadata.type}. Must be one of: \${validTypes.join(\", \")}\`);
                  process.exit(1);
                }
                
                // Validate title length (max 200)
                if (metadata.title && metadata.title.length > 200) {
                  console.error(\`‚ùå Title too long: \${metadata.title}. Must be 200 characters or less\`);
                  process.exit(1);
                }
                
                // Validate description length (max 1000)
                if (metadata.description && metadata.description.length > 1000) {
                  console.error(\`‚ùå Description too long: \${metadata.description}. Must be 1000 characters or less\`);
                  process.exit(1);
                }
                
                // Validate author length (max 200)
                if (metadata.author && metadata.author.length > 200) {
                  console.error(\`‚ùå Author too long: \${metadata.author}. Must be 200 characters or less\`);
                  process.exit(1);
                }
                
                // Validate dependencies arrays
                if (metadata.dependencies && (!Array.isArray(metadata.dependencies) || metadata.dependencies.length > 100)) {
                  console.error(\`‚ùå Invalid dependencies: must be an array with max 100 items\`);
                  process.exit(1);
                }
                
                if (metadata.devDependencies && (!Array.isArray(metadata.devDependencies) || metadata.devDependencies.length > 100)) {
                  console.error(\`‚ùå Invalid devDependencies: must be an array with max 100 items\`);
                  process.exit(1);
                }
                
                if (metadata.registryDependencies && (!Array.isArray(metadata.registryDependencies) || metadata.registryDependencies.length > 100)) {
                  console.error(\`‚ùå Invalid registryDependencies: must be an array with max 100 items\`);
                  process.exit(1);
                }
                
                // Validate categories array
                if (metadata.categories && (!Array.isArray(metadata.categories) || metadata.categories.length > 20)) {
                  console.error(\`‚ùå Invalid categories: must be an array with max 20 items\`);
                  process.exit(1);
                }
                
                // Validate files array
                if (metadata.files && (!Array.isArray(metadata.files) || metadata.files.length > 50)) {
                  console.error(\`‚ùå Invalid files: must be an array with max 50 items\`);
                  process.exit(1);
                }
                
                // Validate files exist and are readable
                if (metadata.files && Array.isArray(metadata.files)) {
                  for (const file of metadata.files) {
                    if (!file.path) {
                      console.error(\`‚ùå File entry missing path field\`);
                      process.exit(1);
                    }
                    
                    // Validate file path length
                    if (file.path.length > 500) {
                      console.error(\`‚ùå File path too long: \${file.path}. Must be 500 characters or less\`);
                      process.exit(1);
                    }
                    
                    const filePath = path.join(componentDir, file.path);
                    if (!fs.existsSync(filePath)) {
                      console.error(\`‚ùå File not found: \${file.path}\`);
                      process.exit(1);
                    }
                    
                    // Check file size (max 100MB)
                    try {
                      const stats = fs.statSync(filePath);
                      const maxSize = 1024 * 1024 * 100;
                      if (stats.size > maxSize) {
                        console.error(\`‚ùå File too large: \${file.path} (\${stats.size} bytes, max \${maxSize})\`);
                        process.exit(1);
                      }
                    } catch (error) {
                      console.error(\`‚ùå File not readable: \${file.path}\`);
                      process.exit(1);
                    }
                  }
                }
                
                // Validate version format (semantic versioning)
                if (metadata.version) {
                  const versionPattern = /^\d+\.\d+\.\d+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$/;
                  if (!versionPattern.test(metadata.version)) {
                    console.error(\`‚ùå Invalid version format: \${metadata.version}. Must follow semantic versioning (e.g., 1.0.0)\`);
                    process.exit(1);
                  }
                }
                
                console.log(\`‚úÖ \${metadata.name} (v\${metadata.version || \"unknown\"}) is valid\`);
              } catch (error) {
                console.error(\`‚ùå Error validating \${componentPath}:\`, error.message);
                process.exit(1);
              }
            "
          ' _ {} \;
          echo "components_valid=true" >> $GITHUB_OUTPUT
          
      - name: Validate component naming conventions
        id: validate-naming
        run: |
          if [ ! -d "components" ]; then
            echo "components_naming_valid=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            const componentsDir = 'components';
            
            // Reserved names from SCM CLI utils.ts
            const reservedNames = [
              \"node_modules\", \"package\", \"package.json\", \"dist\", \"build\", \"test\", \"tests\", \"docs\", \"examples\", \"main\"
            ];
            
            if (fs.existsSync(componentsDir)) {
              const namespaces = fs.readdirSync(componentsDir);
              
              for (const namespace of namespaces) {
                const namespacePath = path.join(componentsDir, namespace);
                if (fs.statSync(namespacePath).isDirectory()) {
                  const componentDirs = fs.readdirSync(namespacePath);
                  
                  for (const componentName of componentDirs) {
                    // Validate namespace format (from SCM CLI)
                    const namespacePattern = /^[a-zA-Z0-9_-]+$/;
                    if (!namespacePattern.test(namespace)) {
                      console.error(\`‚ùå Namespace '\${namespace}' contains invalid characters. Use only letters, numbers, hyphens, and underscores\`);
                      process.exit(1);
                    }
                    
                    if (namespace.length < 1 || namespace.length > 39) {
                      console.error(\`‚ùå Namespace '\${namespace}' length invalid. Must be between 1 and 39 characters\`);
                      process.exit(1);
                    }
                    
                    // Validate component name format (from SCM CLI)
                    const namePattern = /^[a-z][a-z0-9-]*[a-z0-9]$/;
                    if (!namePattern.test(componentName)) {
                      console.error(\`‚ùå Component name '\${componentName}' format invalid. Must start with a letter, contain only lowercase letters, numbers, and hyphens, and end with a letter or number\`);
                      process.exit(1);
                    }
                    
                    // Check reserved names
                    if (reservedNames.includes(componentName.toLowerCase())) {
                      console.error(\`‚ùå Component name '\${componentName}' is reserved and cannot be used\`);
                      process.exit(1);
                    }
                    
                    // Check name length
                    if (componentName.length < 2 || componentName.length > 50) {
                      console.error(\`‚ùå Component name '\${componentName}' length invalid. Must be between 2 and 50 characters\`);
                      process.exit(1);
                    }
                    
                    // Check for consecutive hyphens
                    if (componentName.includes(\"--\")) {
                      console.error(\`‚ùå Component name '\${componentName}' cannot contain consecutive hyphens\`);
                      process.exit(1);
                    }
                  }
                }
              }
            }
            
            console.log('‚úÖ All component names are valid');
          "
          echo "components_naming_valid=true" >> $GITHUB_OUTPUT

      - name: Validation Summary
        id: validation-summary
        run: |
          if [ "${{ steps.validate-registry.outputs.registry_valid }}" == "true" ] && [ "${{ steps.validate-components.outputs.components_valid }}" == "true" ] && [ "${{ steps.validate-naming.outputs.components_naming_valid }}" == "true" ]; then
            echo "‚úÖ All validations passed"
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Validation failed"
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  # Job 2: Auto-merge when validation passes (only for PRs)
  auto-merge:
    needs: validate
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      checks: write
    if: |
      github.event_name == 'pull_request' && 
      github.event.action != 'closed'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y
          
      - name: Check if PR is mergeable
        id: check-mergeable
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Check if PR is mergeable and all checks pass
          MERGEABLE=$(gh pr view ${{ github.event.pull_request.number }} --json mergeable,mergeStateStatus --jq '.mergeable')
          MERGE_STATE=$(gh pr view ${{ github.event.pull_request.number }} --json mergeable,mergeStateStatus --jq '.mergeStateStatus')
          
          echo "Mergeable: $MERGEABLE"
          echo "Merge State: $MERGE_STATE"
          
          if [ "$MERGEABLE" == "MERGEABLE" ] && [ "$MERGE_STATE" == "CLEAN" ]; then
            echo "merge_ready=true" >> $GITHUB_OUTPUT
          else
            echo "merge_ready=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Auto merge PR
        if: steps.check-mergeable.outputs.merge_ready == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ü§ñ Auto-merging PR #${{ github.event.pull_request.number }}"
          gh pr merge ${{ github.event.pull_request.number }} --merge --delete-branch
          echo "‚úÖ PR auto-merged successfully"
          
      - name: Comment merge status
        if: steps.check-mergeable.outputs.merge_ready == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh pr comment ${{ github.event.pull_request.number }} --body "ü§ñ Auto-merged! Component will be available in the registry shortly."
          
      - name: Comment merge blocked
        if: steps.check-mergeable.outputs.merge_ready == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh pr comment ${{ github.event.pull_request.number }} --body "‚ö†Ô∏è Auto-merge blocked. Please check the validation status and resolve any issues."

  # Job 3: Update registry index
  update-index:
    needs: [validate]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    if: |
      (github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push' ||
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true)) &&
      needs.validate.result == 'success'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Generate registry index
        id: generate-index
        run: |
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            const components = [];
            const componentsDir = 'components';
            
            if (fs.existsSync(componentsDir)) {
              const namespaces = fs.readdirSync(componentsDir);
              
              for (const namespace of namespaces) {
                const namespacePath = path.join(componentsDir, namespace);
                if (fs.statSync(namespacePath).isDirectory()) {
                  const componentDirs = fs.readdirSync(namespacePath);
                  
                  for (const componentName of componentDirs) {
                    const componentPath = path.join(namespacePath, componentName);
                    if (fs.statSync(componentPath).isDirectory()) {
                      const versions = fs.readdirSync(componentPath);
                      const latestVersion = versions.sort().pop();
                      
                      if (latestVersion) {
                        const registryPath = path.join(componentPath, latestVersion, 'registry.json');
                        if (fs.existsSync(registryPath)) {
                          try {
                            const metadata = JSON.parse(fs.readFileSync(registryPath, 'utf8'));
                            components.push({
                              name: \`\${namespace}/\${componentName}\`,
                              description: metadata.description || '',
                              author: metadata.author || '',
                              categories: metadata.categories || [],
                              version: latestVersion,
                              lastUpdated: new Date().toISOString()
                            });
                          } catch (error) {
                            console.error(\`Error parsing \${registryPath}:\`, error.message);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            
            // Sort by last updated
            components.sort((a, b) => new Date(b.lastUpdated) - new Date(a.lastUpdated));
            
            fs.writeFileSync('registry.json', JSON.stringify(components, null, 2));
            console.log(\`Updated registry index with \${components.length} components\`);
          "
          echo "components_count=$(node -e "const fs = require('fs'); const registry = JSON.parse(fs.readFileSync('registry.json', 'utf8')); console.log(registry.length);")" >> $GITHUB_OUTPUT
          
      - name: Check for changes
        id: check-changes
        run: |
          git add registry.json
          if git diff --staged --quiet && [ "${{ github.event.inputs.force_update }}" != "true" ]; then
            echo "No changes detected in registry.json"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected in registry.json"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi
          
      - name: Commit and push changes
        if: steps.check-changes.outputs.has_changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Create commit message based on trigger type
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            COMMIT_MSG="chore: manually update registry index [skip ci]"
          elif [ "${{ github.event_name }}" == "push" ]; then
            COMMIT_MSG="chore: update registry index from direct push [skip ci]"
          else
            COMMIT_MSG="chore: update registry index after PR merge [skip ci]"
          fi
          
          git commit -m "$COMMIT_MSG"
          git push origin main
          echo "‚úÖ Registry index updated and pushed"
          
      - name: No changes message
        if: steps.check-changes.outputs.has_changes == 'false'
        run: |
          echo "‚ÑπÔ∏è  No changes detected in registry.json - skipping commit"

  # Job 4: Cleanup branches after merge (only for PRs)
  cleanup:
    needs: [validate]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    if: |
      github.event_name == 'pull_request' && 
      github.event.pull_request.merged == true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
      - name: Delete merged branch
        run: |
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          echo "üóëÔ∏è  Cleaning up merged branch: $BRANCH_NAME"
          
          # Delete the branch locally and remotely
          git push origin --delete "$BRANCH_NAME" || echo "Branch $BRANCH_NAME already deleted or doesn't exist"
          
          echo "‚úÖ Branch cleanup completed" 